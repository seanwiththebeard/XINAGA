#include "Xinaga.h"
#include "GameData.h"
#if defined(__APPLE2__)
#pragma code-name (push, "SCREEN_MAP")
#endif

#if defined (__NES__)
#pragma code-name (push, "MAP")
#pragma rodata-name (push, "MAP")
#pragma data-name (push, "XRAM")
#pragma bss-name (push, "XRAM")
#endif

#if defined (__C64__)
#pragma code-name (push, "SCREEN_MAP")
#pragma rodata-name (push, "SCREEN_MAP")
#endif


//Charset Layout C64
//00-32 - Character Classes (8x 16x16 tiles)
//32-63 - Numbers, symbols
//64-95 - Lowercase characters
//96-127 - NPC/Monsters (8x 16x16 tiles)
//128-191 - Map Tiles (16x 16x16 tiles)
//192-223 - Uppercase Characters
//224-239 - Minimap
//240-255 - Interface

//Charset Layout Apple II (Swap NPCs and Uppercase from C64)
//00-31 - Character Classes (8x 16x16 tiles)
//32-63 - Numbers, symbols
//64-95 - Uppercase characters
//96-127 - Lowercase Characters
//128-191 - Map Tiles (16x 16x16 tiles)
//192-223 - NPC/Monsters (8x 16x16 tiles)
//224-239 - Minimap
//240-255 - Interface

//Overworld Tileset
//Tiles (Terrain):	Water Grass Sand Swamp Snow Tree Mountain Ice
//Tiles (Landmarks):	Castle Town Archive Outpost Dungeon Tower Forrest Dock
//NPCs:			Monster Sign Treasure Gateway Ship Horse ? ?

//Town/Castle Tileset
//Tiles (Terrain):	
//Tiles (Landmarks):	
//NPCs:			

//Dungeon/Tower Tileset
//Tiles (Terrain):	
//Tiles (Landmarks):	
//NPCs:			

//Combat Tileset
//Tiles (Terrain):	
//Tiles (Landmarks):	
//NPCs:			

//Prototypes
//      Map Functions
screenName MapUpdate(void);
static void DrawScreen(void);
static void ActionMenu(void);
static void InitializeMapData(void);
void LoadMap(void);
static void DrawMapViewport(void);
static void DrawEntireMap(void);
#define wrapX(v) do { if ((v) < 0) (v) = mapWidth - 1; else if ((v) >= mapWidth) (v) = 0; } while(0)
#define wrapY(v) do { if ((v) < 0) (v) = mapHeight - 1; else if ((v) >= mapHeight) (v) = 0; } while(0)
//void DrawSquare(sbyte xOrigin, sbyte yOrigin, sbyte xSize, sbyte ySize);
static void ApplyLOS(void);
static void CameraFollow(void);
static void BufferCharacters(void);
static void MoveCharacter(byte index, byte dir);
static bool CheckCollision(byte charIndex, byte Direction);
static void DrawCharacterCoordinates(byte index);
static void UpdatePlayerOnMiniMap(void);

//      Quad Functions
static void FillQuadBuffer(void);
static void LoadQuadrant(byte quadIndex, byte quad);
void LoadMapQuads(void);
static byte GetPlayerQuad(void); //Returns the viewport quadrant of the player character
static byte GetQuadInRelation(sbyte v, sbyte h);
static void QuadScroll(byte direction);

//Globals
#define playerX ((viewportWidth - 1) >> 1) //Viewport Center used in line-of-sight calculations
#define playerY ((viewportHeight - 1) >> 1) //Viewport Center used in line-of-sight calculations
#define viewportSize viewportHeight * viewportWidth
static byte viewportBuffer[viewportSize];
static byte viewportBufferLast[viewportSize];
byte followIndex;
byte SetPlayerPositionX;
byte SetPlayerPositionY;

//Camera Position
static sbyte offsetX;
static sbyte offsetY;

static byte CoordPosX;
static byte CoordPosY;

//Map Data
static bool LOSEnabled;
#define EmptyTile 32
#define mapHeight 32
#define mapWidth 32
static byte mapData[mapWidth * mapHeight];

//Quad Data
byte mapQuads[mapMatrixHeight * mapMatrixWidth];  //These are the quad-tile references that make up the map

static struct
{ //These are the quad indexes referenced in mapQuads[y][x]
  #define ScreenQuadCount 64
  byte CharIndex[ScreenQuadCount][4]; //The graphic characters that make up the tile placement
  byte Chars[ScreenQuadCount][2]; //Which tiles for a zero or a 1 in the bits of a CharIndex
  byte ScatterIndex[ScreenQuadCount]; //Which fluff arrangement to add on top of above?
}ScreenQuad;
byte quadBuffer[4];

#define quadWidth 8
#define quadHeight 8
#define quadWidthDouble 16
#define quadHeightDouble 16

static const byte MapSet[] = { /*{w:8,h:8,bpp:1,count:256,brev:1,pal:"c64",np:1}*/
  0x00,0x3C,0x60,0x40,0x40,0x40,0x00,0x00,0x00,0x3C,0x06,0x02,0x02,0x02,0x00,0x00
    ,0xE7,0x81,0x81,0x00,0x00,0x81,0x81,0xE7,0xC3,0xC3,0xC3,0x00,0x00,0xC3,0xC3,0xC3
    ,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01
    ,0x00,0x00,0x40,0x40,0x40,0x60,0x3C,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x3C,0x00
    ,0xE7,0x81,0x81,0x00,0x00,0x81,0x81,0xE7,0xFF,0x81,0x81,0x81,0x81,0x81,0x81,0xFF
    ,0x00,0x00,0x3F,0x20,0x20,0x27,0x24,0x24,0x00,0x00,0xFF,0x00,0x00,0xE7,0x24,0x24
    ,0x00,0x00,0xFC,0x04,0x04,0xE4,0x24,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0xBD,0xFF,0xFF,0xFF,0xFF,0xBD,0xFF
    ,0x00,0x66,0x42,0x00,0x00,0x42,0x66,0x00,0xC3,0xC3,0xC3,0x00,0x00,0xC3,0xC3,0xC3
    ,0x24,0x24,0x27,0x20,0x20,0x27,0x24,0x24,0x24,0x24,0xE7,0x00,0x00,0xE7,0x24,0x24
    ,0x24,0x24,0xE4,0x04,0x00,0xE4,0x24,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF
    ,0x24,0x24,0x27,0x20,0x20,0x3F,0x00,0x00,0x24,0x24,0xE7,0x00,0x00,0xFF,0x00,0x00
    ,0x24,0x24,0xE4,0x04,0x04,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01
    ,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x20,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x10,0x00
    ,0x01,0x01,0x01,0x01,0x01,0x01,0x03,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0xC0,0xFF
    ,0x00,0x04,0x00,0x40,0x02,0x00,0x10,0x00,0x00,0x08,0x00,0x00,0x44,0x00,0x20,0x00
    ,0x00,0x77,0x40,0x40,0x40,0x05,0x44,0x44,0x00,0xEE,0x02,0x00,0x02,0xE2,0x22,0x22
    ,0x00,0x7F,0x46,0x56,0x56,0x56,0x56,0x50,0x00,0xDE,0x10,0xD6,0xD6,0xC6,0x2E,0x2E
    ,0x07,0x03,0x01,0x00,0x00,0x80,0xC0,0xE0,0xE0,0xC0,0x80,0x00,0x00,0x01,0x03,0x07
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x08,0x00,0x40,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x02,0x00,0x20,0x00,0x00
    ,0xFF,0x03,0x01,0x01,0x01,0x01,0x01,0x01,0xFF,0xC0,0x80,0x80,0x80,0x80,0x80,0x80
    ,0x00,0x08,0x00,0x01,0x40,0x10,0x00,0x00,0x00,0x04,0x40,0x00,0x00,0x10,0x02,0x00
    ,0x44,0x44,0x47,0x00,0x40,0x40,0x7E,0x00,0x22,0x22,0xE0,0x02,0x02,0x02,0x7E,0x00
    ,0x54,0x56,0x57,0x51,0x5D,0x44,0x77,0x00,0x1E,0x42,0x6A,0x0A,0xFA,0x02,0xFE,0x00
    ,0xE0,0xC0,0x80,0x00,0x00,0x01,0x03,0x07,0x07,0x03,0x01,0x00,0x00,0x80,0xC0,0xE0
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

static struct
{
  #define charactersCount 8
  byte tile[charactersCount];
  byte combat[charactersCount];
  byte message[charactersCount];
  bool visible[charactersCount];
  bool collide[charactersCount];
  sbyte posX[charactersCount];
  sbyte posY[charactersCount];
  sbyte quadPosX[charactersCount];
  sbyte quadPosY[charactersCount];
}characters;

static void CameraFollow()
{
  offsetX = characters.posX[followIndex] - playerX;
  if (offsetX < 0) offsetX += mapWidth;

  offsetY = characters.posY[followIndex] - playerY;
  if (offsetY < 0) offsetY += mapHeight;
}


static void BufferCharacters()
{
  byte i;
  sbyte rx, ry;
  for (i = 0; i < charactersCount; ++i)
  {
    if (!characters.visible[i]) continue;

    rx = characters.posX[i] - offsetX;
    if (rx < 0) rx += mapWidth;
    if (rx >= viewportWidth) continue;

    ry = characters.posY[i] - offsetY;
    if (ry < 0) ry += mapHeight;
    if (ry >= viewportHeight) continue;

    viewportBuffer[rx + ry * viewportWidth] = characters.tile[i];
  }
}


static void UpdatePlayerOnMiniMap(void)
{
  //MiniMapHighlightX = characters.quadPosX[followIndex];
  //MiniMapHighlightY = characters.quadPosY[followIndex];

  MiniMapHighlightX = CoordPosX >> 4;
  MiniMapHighlightY = CoordPosY >> 4;
}

static void FillQuadBuffer()
{
  byte quadX = characters.quadPosX[followIndex];
  byte quadY = characters.quadPosY[followIndex];  
  byte byte_x = (quadX + 1) & (quadWidth - 1);
  byte byte_y = (quadY + 1) & (quadHeight - 1);
  byte row0 = mapMatrixWidth * quadY;
  byte row1 = mapMatrixWidth * byte_y; 
  quadBuffer[0] = mapQuads[quadX + row0]; 
  quadBuffer[1] = mapQuads[byte_x + row0]; 
  quadBuffer[2] = mapQuads[quadX + row1]; 
  quadBuffer[3] = mapQuads[byte_x + row1];
}

static const byte quadOriginsX[4] = 	{0, quadWidthDouble, 		0, 		quadWidthDouble}; 		//Tile Origin
static const byte quadOriginsY[4] = 	{0, 0, 				quadHeightDouble, 	quadHeightDouble};
static const byte quadOffsetX[4] = 	{0, quadWidth, 			0, 			quadWidth};		//Subchars
static const byte quadOffsetY[4] = 	{0, 0, 				quadHeight, 		quadHeight};
static void LoadQuadrant(byte quadIndex, byte quad)
{
  byte byte_y, byte_z, QuadOriginX, QuadOriginY, charByte;
  byte *out;
  const byte *tilePtr;
  const byte *chars = ScreenQuad.Chars[quadIndex];
  int rowStart;

  quadBuffer[quad] = quadIndex;

  for (byte_z = 0; byte_z < 4; ++byte_z)
  {
    QuadOriginX = quadOriginsX[quad] + quadOffsetX[byte_z];
    QuadOriginY = quadOriginsY[quad] + quadOffsetY[byte_z];
    // Precompute tile base pointer once per tile
    tilePtr = &MapSet[ScreenQuad.CharIndex[quadIndex][byte_z] << 3];
    rowStart = mapWidth * (QuadOriginY);
    for (byte_y = 0; byte_y < quadHeight; ++byte_y)
    {
      charByte = tilePtr[byte_y];
      out = &mapData[QuadOriginX + rowStart];
      *out++ = chars[(charByte >> 7) & 1];
      *out++ = chars[(charByte >> 6) & 1];
      *out++ = chars[(charByte >> 5) & 1];
      *out++ = chars[(charByte >> 4) & 1];
      *out++ = chars[(charByte >> 3) & 1];
      *out++ = chars[(charByte >> 2) & 1];
      *out++ = chars[(charByte >> 1) & 1];
      *out++ = chars[ charByte	     & 1];
      rowStart += mapWidth;
    }
  }
}

void LoadMapQuads()
{
  //byte x;
  FillQuadBuffer();
  LoadQuadrant(quadBuffer[0], 0);
  LoadQuadrant(quadBuffer[1], 1);
  LoadQuadrant(quadBuffer[2], 2);
  LoadQuadrant(quadBuffer[3], 3);
}

typedef struct { sbyte vA, vB, hA, hB; } QuadRel;
static const QuadRel quadRel[8] = {
  {-1, -1,  0, -1},
  { 1,  1,  0, -1},
  { 0, -1, -1, -1},
  { 0, -1,  1,  1},
  {-1, -1,  0,  1},
  { 1,  1,  0,  1},
  { 0,  1, -1, -1},
  { 0,  1,  1,  1}
};


//Quad positions in the matrix for which way we're moving
static const byte CompareQuadValueA[8] = {2, 3, 0, 1, 1, 0, 3, 2};
static const byte CompareQuadValueB[8] = {3, 2, 1, 0, 3, 2, 1, 0};

static void QuadScroll(direction dir)
{
  byte quadA, quadB;
  byte indexA, indexB;

  // Fast bit tests: (pos & 8) == 0 means "in left/top half of tile"
  byte posX = characters.posX[followIndex];
  byte posY = characters.posY[followIndex];

  bool charPosX = !(posX & 8);
  bool charPosY = !(posY & 8);

  // relH / relV selection
  byte relH = dir | (charPosX ? 0 : 4);
  byte relV = dir | (charPosY ? 0 : 4);

  // Compute compareQuad without branches
  byte compareQuad =
    ((posX >> 4) & 1) |
    (((posY >> 4) & 1) << 1) |
    ((dir > 1) << 2);

  // Inline GetQuadInRelation() using bitmask wrap (matrix is 16Ã—16)
  byte qx = characters.quadPosX[followIndex];
  byte qy = characters.quadPosY[followIndex];

  indexA = mapQuads[((qx + quadRel[relH].hA) & 15)
                    + (((qy + quadRel[relV].vA) & 15) << 4)];

  indexB = mapQuads[((qx + quadRel[relH].hB) & 15)
                    + (((qy + quadRel[relV].vB) & 15) << 4)];

  quadA = CompareQuadValueA[compareQuad];
  quadB = CompareQuadValueB[compareQuad];

  if (quadBuffer[quadA] != indexA)
    LoadQuadrant(indexA, quadA);

  if (quadBuffer[quadB] != indexB)
    LoadQuadrant(indexB, quadB);
}



static void InitializeMapData()
{

  byte byte_x;
  byte byte_y;
  byte byte_i;
  int byte_offset;
  int byte_index = 0;
  //memset(&mapQuads[0], 0, 256);
  
  SetPlayerPositionX = 8;
  SetPlayerPositionY = 8;  

  for (byte_y = 0; byte_y < 16; ++byte_y)
    for (byte_x = 0; byte_x < 16; ++byte_x)
    {
      //mapQuads[byte_x + 16*byte_y] = 16;
      
      mapQuads[byte_x + 16*byte_y] = byte_x + 16*byte_y;
    }

  for (byte_x = 0; byte_x < TileCount; ++byte_x)
  {
    tilesPalette[byte_x] = 1;
    tilesBlocked[byte_x] = 0;
    tilesOpaque[byte_x] = 0;

    if (byte_x < 8)
      tilesPalette[byte_x] = 0;
  }

  //Quad definitions (64 tiles)
  for (byte_y = 0; byte_y < 8; ++byte_y)
    for (byte_x = 0; byte_x < 8; ++byte_x)
    {
      byte_index = byte_x + (8* byte_y);
      byte_offset = (byte_x << 1) + (byte_y << 5);

      ScreenQuad.CharIndex[byte_index][0] = byte_offset; // Init screen quad prefabs for 8x8
      ScreenQuad.CharIndex[byte_index][1] = byte_offset + 1;
      ScreenQuad.CharIndex[byte_index][2] = byte_offset + 16;
      ScreenQuad.CharIndex[byte_index][3] = byte_offset + 17;
      //ScreenQuad.Chars[byte_index][0] = 32;
      //ScreenQuad.Chars[byte_index][1] = byte_index;
      //ScreenQuad.Chars[byte_index][0] = grass;
      //ScreenQuad.Chars[byte_index][1] = tree;

      ScreenQuad.Chars[byte_index][0] = 36;
      ScreenQuad.Chars[byte_index][1] = 36;

      ScreenQuad.ScatterIndex[byte_index] = 0;
      //++byte_index;
    }


  //ScreenQuad.Chars[63][0] = water;
  //ScreenQuad.Chars[63][1] = water;
  //ScreenQuad.Chars[62][0] = grass;
  //ScreenQuad.Chars[62][1] = grass;

  //ScreenQuad.Chars[2][0] = 36; // Set the wizard to grass on 0
  //ScreenQuad.Chars[2][1] = 44; // Set the wizard to trees on 1
  
  /*
  Tile Offset 32
  0 Water
  0 = Water 2
  1 = Rocks 10
  Index 56
  
  1 Roads
  0 = Grass 4
  1 = Roads 14
  Index 57
  
  2 Grass
  0 - Grass 4
  1 - Trees 12
  Index 58
  
  3 Forest
  0 - Grass 4
  1 - Trees 12
  Index 59
  
  4 Mountains
  0 = Grass 4
  1 - Rocks 10
  Index 60
  
  5 - Ocean Travel
  0 - Water 2
  1 - Grass 4
  Index 61
  */
  
  #define grass 36
  #define water 34
  #define signpost 35
  #define tree 44
  #define rocks 42
  #define road 46
  
  tilesOpaque[tree] = true; //Trees
  tilesOpaque[rocks] = true; //rocks
  
  tilesPalette[tree] = 3; //Trees
  tilesPalette[signpost] = 2; //Sign
  //ScreenQuad.Chars[0][0] = water;
  //ScreenQuad.Chars[0][1] = rocks;
  
  ScreenQuad.Chars[56][0] = water;
  ScreenQuad.Chars[56][1] = rocks;
  
  ScreenQuad.Chars[57][0] = grass;
  ScreenQuad.Chars[57][1] = road;
  
  ScreenQuad.Chars[58][0] = grass;
  ScreenQuad.Chars[58][1] = tree;
  
  ScreenQuad.Chars[59][0] = grass;
  ScreenQuad.Chars[59][1] = tree;
  
  ScreenQuad.Chars[60][0] = grass;
  ScreenQuad.Chars[60][1] = rocks;
  
  ScreenQuad.Chars[61][0] = water;
  ScreenQuad.Chars[61][1] = rocks;

  //Init Characters
  for (byte_i = 0; byte_i < charactersCount; ++byte_i)
  {
    characters.tile[byte_i] = byte_i;
    characters.posX[byte_i] = byte_i;
    characters.posY[byte_i] = byte_i;
    characters.quadPosX[byte_i] = byte_i;
    characters.quadPosY[byte_i] = byte_i;
    characters.visible[byte_i] = false;
    characters.collide[byte_i] = false;
  }
  characters.visible[0] = true;
  characters.posX[0]  = 12;
  characters.posY[0]  = 12;
  characters.quadPosX[0]  = SetPlayerPositionX;
  characters.quadPosY[0]  = SetPlayerPositionY;
  //characters.quadPosX[0]  = 1;
  //characters.quadPosY[0]  = 0;
  characters.tile[0] = 2;

  characters.visible[1] = true;
  characters.collide[1] = true;
  characters.message[1] = 0;

  characters.tile[2] = signpost;
  characters.visible[2] = true;
  characters.collide[2] = true;
  characters.message[2] = 1;
  characters.posX[2] = 12;
  characters.posY[2] = 11;
  characters.quadPosX[2]  = 1;
  characters.quadPosY[2]  = 0;

  LoadMapQuads();
  UpdatePlayerOnMiniMap();
  LOSEnabled = true;
}

static bool CheckCollision(byte charIndex, direction dir)
{
  byte byte_i;
  sbyte xPos = characters.posX[charIndex];
  sbyte yPos = characters.posY[charIndex]; //These need to be signed because they can wrap around the map

  //Check the tile we're already standing on
  if(ReadBit(tilesBlocked[mapData[xPos + (mapWidth * yPos)]], dir))
  {
    //WriteLineMessageWindow("Standing on blocked@", 0);
    return true;
  }

  switch (dir)
  {
    case up:
      --yPos;
      wrapY(yPos);
      break;
    case down:
      ++yPos;
      wrapY(yPos);
      break;
    case left:
      --xPos;
      wrapX(xPos);
      break;
    case right:
      ++xPos;
      wrapX(xPos);
      break;
    default:
      return false;
  }

  if(ReadBit(tilesBlocked[mapData[xPos + (mapWidth *yPos)]], dir))
  {
    /*WriteLineMessageWindow("Entry blocked@", 1);
    sprintf(str, "Index: %d@", tiles[mapData[xPos][yPos]].index);
    WriteLineMessageWindow(str, 1);
    sprintf(str, "Data: %d@", tiles[mapData[xPos][yPos]].blocked);
    WriteLineMessageWindow(str, 1);
    sprintf(str, "position: %d,%d@", xPos, yPos);
    WriteLineMessageWindow(str, 1);*/
    return true;
  }

  //Call Messagebox from NPC
  for (byte_i = 0; byte_i < charactersCount; ++byte_i)
    if(characters.collide[byte_i])
      if (characters.posX[byte_i] == xPos)
        if (characters.posY[byte_i] == yPos)
        {
          WriteLineMessageWindow((char*)Messages[characters.message[byte_i]], 1);
          return true;
        }

  return false;
}

static void DrawSquare(byte xOrigin, byte yOrigin, byte xSize, byte ySize) //LOS Blocking
{
  byte yEnd, row, offset;
  if ( !xSize || !ySize )
    return;
  yEnd = yOrigin + ySize; 
  row = yOrigin;
  offset = (row * viewportWidth) + xOrigin;
  do { memset(&viewportBuffer[offset], EmptyTile, xSize); ++row; offset += viewportWidth; } while (row < yEnd);
}

static void ApplyLOS()
{
  byte pX = playerX;
  byte pY = playerY;
  byte rowBase = 0;
  byte x, y, xDist, yDist, tile;

  for (y = 0; y < viewportHeight; ++y)
  {
    yDist = viewportHeight - y - 1;

    for (x = 0; x < viewportWidth; ++x)
    {
      tile = viewportBuffer[rowBase + x];
      if (tile == EmptyTile || !tilesOpaque[tile])
        continue;

      xDist = viewportWidth - x - 1;
      if (!xDist)
        continue;

      if (x < pX)
      {
        if (y == pY) { DrawSquare(0, y - 1, x, 3); continue; }
        if (y < pY)  { DrawSquare(0, 0, x, y); continue; }
        /* y > pY */ DrawSquare(0, y + 1, x, yDist); continue;
      }

      if (x > pX)
      {
        if (y == pY) { DrawSquare(x + 1, y - 1, xDist, 3); continue; }
        if (y < pY)  { DrawSquare(x + 1, 0, xDist, y); continue; }
        /* y > pY */ DrawSquare(x + 1, y + 1, xDist, yDist); continue;
      }

      // x == pX
      if (y < pY)  { DrawSquare(x - 1, 0, 3, y); continue; }
      if (y > pY)  { DrawSquare(x - 1, y + 1, 3, yDist); continue; }
    }

    rowBase += viewportWidth;
  }
}


static void DrawEntireMap()
{
  byte byte_x;
  byte byte_y;
  byte viewportOffset = 0;
  byte offset;
  int mapOffset;
  CameraFollow();
  for(byte_y = 0; byte_y < viewportHeight; ++byte_y)
  {
    mapOffset = (mapWidth * ((offsetY + byte_y) & 31));
    for(byte_x = 0; byte_x < viewportWidth; ++byte_x)
    {
      viewportBuffer[byte_x + viewportOffset] = mapData[((offsetX + byte_x) & 31) + mapOffset];      
    }
    viewportOffset += viewportWidth;
  }
  BufferCharacters();
  if(LOSEnabled)
    ApplyLOS();
  MapFadeOut();
  offset = 0;
  tilePosY = 0;
  for(byte_y = 0; byte_y < viewportHeight; ++byte_y)
  {
    tilePosX = 0;
    for(byte_x = 0; byte_x < viewportWidth; ++byte_x)
    { 
      byte newIndex = viewportBuffer[offset];
      if (viewportBufferLast[offset] != newIndex)
      {
        DrawTileSeq(newIndex);
        viewportBufferLast[offset] = newIndex;
      }
      ++tilePosX;
      ++offset;
    }
    ++tilePosY;
  }
  DrawCharacterCoordinates(followIndex);
  UpdateAttributes();
  MapFadeIn();
}

static void MoveCharacter(byte index, byte dir)
{
  bool scrollQuads = false;
  bool changedQuads = false;
  byte checkCollision = CheckCollision(index, dir);

  TickMoonPhase();
  if(!checkCollision)
  {
    switch (dir)
    {
      case up:
        --characters.posY[index];
        if (characters.posY[index] < 0)
          characters.posY[index] = mapHeight - 1;
        if (characters.posY[index] == 15 || characters.posY[index] == 31)
        {
          --characters.quadPosY[index];
          changedQuads = true;
          if(characters.quadPosY[index] < 0)
            characters.quadPosY[index] = mapMatrixHeight - 1;
        }
        break;
      case down:
        ++characters.posY[index];
        if (characters.posY[index] >= mapHeight)
          characters.posY[index] = 0;
        if (characters.posY[index] == 0 || characters.posY[index] == 16)
        {
          ++characters.quadPosY[index];
          changedQuads = true;
          if(characters.quadPosY[index] == mapMatrixHeight)
            characters.quadPosY[index] = 0; 
        }
        break;
      case left:
        --characters.posX[index];
        if (characters.posX[index] < 0)
          characters.posX[index] = mapWidth - 1;
        if (characters.posX[index] == 15 || characters.posX[index] == 31)
        {
          --characters.quadPosX[index];
          changedQuads = true;
          if(characters.quadPosX[index] < 0)
            characters.quadPosX[index] = mapMatrixWidth - 1; 
        }
        break;
      case right:
        ++characters.posX[index];
        if (characters.posX[index] >= mapWidth)
          characters.posX[index] = 0;
        if (characters.posX[index] == 0 || characters.posX[index] == 16)
        {
          ++characters.quadPosX[index];
          changedQuads = true;
          if(characters.quadPosX[index] == mapMatrixWidth)
            characters.quadPosX[index] = 0; 
        }
        break;
      default:
        break;
    }

    if (index == followIndex)
    {
      byte edgeCheckX = characters.posX[index] % 16;
      byte edgeCheckY = characters.posY[index] % 16;
      if(changedQuads)
        UpdatePlayerOnMiniMap();

      switch (dir)
      {
        case 0:
          if (edgeCheckY == 6)
            scrollQuads = true;
          break;
        case 1:
          if (edgeCheckY == 10)
            scrollQuads = true;
          break;
        case 2:
          if (edgeCheckX == 6)
            scrollQuads = true;
          break;
        case 3:
          if (edgeCheckX == 10)
            scrollQuads = true;
          break;
      }
      if (scrollQuads)
      {
        //SetBG(0x0b);
        //SetBorder(0x0b);
        QuadScroll(dir);
        //SetBG(0);
        //SetBorder(0);
      }
    }
    DrawEntireMap();
  }
}

static void DrawCharacterCoordinates(byte index)
{
  CoordPosX = characters.posX[index];
  CoordPosY = characters.posY[index];

  if (CoordPosX >= quadWidth * 2)
    CoordPosX -= quadWidth * 2;
  CoordPosX += quadWidth*2*characters.quadPosX[index];

  if (CoordPosY >= quadHeight * 2)
    CoordPosY -= quadHeight * 2;
  CoordPosY += quadHeight*2*characters.quadPosY[index];  

  sprintf(strTemp,"<%3i  %3i>@", CoordPosX, CoordPosY);
  PrintString(strTemp, viewportPosX + (viewportWidth >> 1), viewportPosY + (viewportHeight << 1), true);
}

void LoadMap()
{
  InitializeMapData();
}

//#define consoleDelay 1
//#define menuPosX  3 + ROWS - (ROWS - consoleWidth)
//#define menuPosY consolePosY - 1
#define menuWidth 13
#define menuCount 6
#define menuHeight menuCount

static void DrawMapViewport(void)
{
  memset(&viewportBufferLast, 255, viewportSize);
  DrawEntireMap();
  //DrawCharacterCoordinates(followIndex);
}
static void DrawScreen(void)
{
  DrawMapViewport();
  DrawCharStats();
}

static bool exitScreen;
static void ActionMenu()
{
  byte action;
  ResetMenu("@", contextMenuPosX, contextMenuPosY, contextMenuWidth, contextMenuHeight, menuCount);
  SetMenuItem(0, "Search@");
  SetMenuItem(1, "Attack@");
  SetMenuItem(2, "Party@");
  SetMenuItem(3, "Map@");
  SetMenuItem(4, "Exit@");
  SetMenuItem(5, "Charset@");

  action = GetMenuSelection();
  ClearMenu();
  switch (action)
  {
    case 0:
      break;
    case 1:
      break;
    case 2:
      break;
    case 3:
      UpdatePlayerOnMiniMap();
      ScreenFadeOut();
      //ClearScreen();
      DrawMiniMap(true);
      WaitForInput();
      ScreenFadeOut();
      DrawMap();
      ScreenFadeIn();
      //DrawMapViewport();
      break;
    case 4:
      exitScreen = true;
      ScreenFadeOut();
      break;
    case 5:
      DrawCharset();
      WaitForInput();
      DrawMapViewport();
      break;
  }
  DrawCharStats();
}

void DrawMap()
{

  ResizeMessageWindow(consolePosX, consolePosY, consoleWidth, consoleHeight);
  DrawBorder("@", viewportPosX - 1, viewportPosY - 1, viewportWidth* 2 + 2, viewportHeight * 2 + 2, true);
  DrawScreen();
}
byte lastMiniMapX;
byte lastMiniMapY;

screenName MapUpdate()
{
  exitScreen = false;
  MiniMapPosX = 20;
  MiniMapPosY = 1;
  characters.quadPosX[0]  = SetPlayerPositionX;
  characters.quadPosY[0]  = SetPlayerPositionY;

  ResizeMessageWindow(consolePosX, consolePosY, consoleWidth, consoleHeight);
  DrawBorder("@", viewportPosX - 1, viewportPosY - 1, viewportWidth* 2 + 2, viewportHeight * 2 + 2, true);
  DrawCharStats();
  SetTileOrigin(viewportPosX, viewportPosY);
  LoadMapQuads();
  FillViewport(32, viewportWidth, viewportHeight);
  ScreenFadeIn();
  DrawMapViewport();
  UpdatePlayerOnMiniMap();
  DrawMiniMap(true);


  while (!exitScreen)
  {
    UpdateInput();
    //if (InputChanged())
    {
      direction Dir = 4;
      if (InputUp())
        Dir = up;
      if (InputDown()) 
        Dir = down;
      if (InputLeft())
        Dir = left;
      if (InputRight())
        Dir = right;
      if (InputFire())
        if (InputChanged())
          ActionMenu();
      if (Dir < 4)
      {
        MoveCharacter(followIndex, Dir);
        DrawCharacterCoordinates(followIndex);
        {
          SetChar(MiniMapGlyphs[mapQuads[lastMiniMapX + mapMatrixWidth * lastMiniMapY]], MiniMapPosX + MiniMapHighlightX, MiniMapPosY + MiniMapHighlightY);
          UpdatePlayerOnMiniMap();
          lastMiniMapX = MiniMapHighlightX;
          lastMiniMapY = MiniMapHighlightY;          
          SetChar('X', MiniMapPosX + MiniMapHighlightX, MiniMapPosY + MiniMapHighlightY);
        }

      }
    }
  }
  ScreenFadeOut();
  return EditParty;
}
