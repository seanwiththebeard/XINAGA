#include "Xinaga.h"
#include "GameData.h"
#if defined(__APPLE2__)
#pragma code-name (push, "LC")
#endif

#if defined (__NES__)
#pragma code-name (push, "MAP")
#pragma rodata-name (push, "MAP")
#pragma data-name (push, "XRAM")
#pragma bss-name (push, "XRAM")
#endif

//Prototypes
//      Map Functions
screenName MapUpdate(void);
static void DrawScreen(void);
static void ActionMenu(void);
static void InitializeMapData(void);
void LoadMap(void);
static void DrawMapViewport(void);
static void DrawEntireMap(void);
//void wrapX(sbyte *posX); //Used in map positions
//void wrapY(sbyte *posY);
#define wrapX(v) do { if ((v) < 0) (v) = mapWidth - 1; else if ((v) >= mapWidth) (v) = 0; } while(0)
#define wrapY(v) do { if ((v) < 0) (v) = mapHeight - 1; else if ((v) >= mapHeight) (v) = 0; } while(0)
//void DrawSquare(sbyte xOrigin, sbyte yOrigin, sbyte xSize, sbyte ySize);
static void ApplyLOS(void);
static void CameraFollow(void);
static void BufferCharacters(void);
static void MoveCharacter(byte index, byte dir);
static bool CheckCollision(byte charIndex, byte Direction);
static void DrawCharacterCoordinates(byte index);
static void UpdatePlayerOnMiniMap(void);

//      Quad Functions
static void FillQuadBuffer(void);
static void LoadQuadrant(byte quadIndex, byte quad);
void LoadMapQuads(void);
static byte GetPlayerQuad(void); //Returns the viewport quadrant of the player character
static byte GetQuadInRelation(sbyte v, sbyte h);
static void QuadScroll(byte direction);


//Charset Layout C64
//00-32 - Character Classes (8x 16x16 tiles)
//32-63 - Numbers, symbols
//64-95 - Lowercase characters
//96-127 - NPC/Monsters (8x 16x16 tiles)
//128-191 - Map Tiles (16x 16x16 tiles)
//192-223 - Uppercase Characters
//224-239 - Minimap
//240-255 - Interface

//Charset Layout Apple II (Swap NPCs and Uppercase from C64)
//00-31 - Character Classes (8x 16x16 tiles)
//32-63 - Numbers, symbols
//64-95 - Uppercase characters
//96-127 - Lowercase Characters
//128-191 - Map Tiles (16x 16x16 tiles)
//192-223 - NPC/Monsters (8x 16x16 tiles)
//224-239 - Minimap
//240-255 - Interface

//Overworld Tileset
//Tiles (Terrain):	Water Grass Sand Swamp Snow Tree Mountain Ice
//Tiles (Landmarks):	Castle Town Archive Outpost Dungeon Tower Forrest Dock
//NPCs:			Monster Sign Treasure Gateway Ship Horse ? ?

//Town/Castle Tileset
//Tiles (Terrain):	
//Tiles (Landmarks):	
//NPCs:			

//Dungeon/Tower Tileset
//Tiles (Terrain):	
//Tiles (Landmarks):	
//NPCs:			

//Combat Tileset
//Tiles (Terrain):	
//Tiles (Landmarks):	
//NPCs:			



//Globals
#define playerX ((viewportWidth - 1) >> 1) //Viewport Center used in line-of-sight calculations
#define playerY ((viewportHeight - 1) >> 1) //Viewport Center used in line-of-sight calculations
#define viewportSize viewportHeight * viewportWidth
static byte viewportBuffer[viewportSize];
static byte viewportBufferLast[viewportSize];
byte followIndex;

//Camera Position
static sbyte offsetX;
static sbyte offsetY;

static byte CoordPosX;
static byte CoordPosY;

//Map Data
static bool LOSEnabled;
#define EmptyTile 32
#define mapHeight 32
#define mapWidth 32
static byte mapData[mapWidth * mapHeight];
static const byte MapSet[] = { /*{w:8,h:8,bpp:1,count:256,brev:1,pal:"c64",np:1}*/
  0x00,0x3C,0x60,0x40,0x40,0x40,0x00,0x00,0x00,0x3C,0x06,0x02,0x02,0x02,0x00,0x00
    ,0xE7,0x81,0x81,0x00,0x00,0x81,0x81,0xE7,0xC3,0xC3,0xC3,0x00,0x00,0xC3,0xC3,0xC3
    ,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01
    ,0x00,0x00,0x40,0x40,0x40,0x60,0x3C,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x3C,0x00
    ,0xE7,0x81,0x81,0x00,0x00,0x81,0x81,0xE7,0xFF,0x81,0x81,0x81,0x81,0x81,0x81,0xFF
    ,0x00,0x00,0x3F,0x20,0x20,0x27,0x24,0x24,0x00,0x00,0xFF,0x00,0x00,0xE7,0x24,0x24
    ,0x00,0x00,0xFC,0x04,0x04,0xE4,0x24,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
    ,0x00,0x66,0x42,0x00,0x00,0x42,0x66,0x00,0xC3,0xC3,0xC3,0x00,0x00,0xC3,0xC3,0xC3
    ,0x24,0x24,0x27,0x20,0x20,0x27,0x24,0x24,0x24,0x24,0xE7,0x00,0x00,0xE7,0x24,0x24
    ,0x24,0x24,0xE4,0x04,0x00,0xE4,0x24,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xFF
    ,0x24,0x24,0x27,0x20,0x20,0x3F,0x00,0x00,0x24,0x24,0xE7,0x00,0x00,0xFF,0x00,0x00
    ,0x24,0x24,0xE4,0x04,0x04,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};

static struct
{
  #define charactersCount 8
  byte tile[charactersCount];
  byte combat[charactersCount];
  byte message[charactersCount];
  bool visible[charactersCount];
  bool collide[charactersCount];
  sbyte posX[charactersCount];
  sbyte posY[charactersCount];
  sbyte quadPosX[charactersCount];
  sbyte quadPosY[charactersCount];
}characters;

static void CameraFollow()
{
  byte byte_x;
  byte byte_y;
  byte pX = playerX;
  byte pY = playerY;
  offsetX = characters.posX[followIndex];
  offsetY = characters.posY[followIndex];

  for(byte_x = 0; byte_x < pX; ++byte_x)
  {
    --offsetX;
    wrapX(offsetX);
  }

  for(byte_y = 0; byte_y < pY; ++byte_y)
  {
    --offsetY;
    wrapY(offsetY);
  }
}

static void BufferCharacters()
{
  byte byte_x;
  byte byte_y;
  byte byte_i;
  for(byte_i = 0; byte_i < charactersCount; ++byte_i)
  {
    if(characters.visible[byte_i])
    {
      byte_x = characters.posX[byte_i];
      if(byte_x < offsetX)
        byte_x = (byte_x - offsetX + mapWidth);
      else
        byte_x = byte_x - offsetX;

      if (byte_x < viewportWidth)
      {
        byte_y = characters.posY[byte_i];
        if (byte_y < offsetY)
          byte_y = byte_y - offsetY + mapHeight;
        else
          byte_y = byte_y - offsetY;
        if (byte_y < viewportHeight)
          viewportBuffer[byte_x + (viewportWidth * byte_y)] = characters.tile[byte_i];
      }
    }
  }
}

static void UpdatePlayerOnMiniMap(void)
{
  //MiniMapHighlightX = characters.quadPosX[followIndex];
  //MiniMapHighlightY = characters.quadPosY[followIndex];

  MiniMapHighlightX = CoordPosX >> 4;
  MiniMapHighlightY = CoordPosY >> 4;
}

//Quad Data
byte mapQuads[mapMatrixHeight * mapMatrixWidth] = {0};  //These are the quad-tile references that make up the map

static struct
{ //These are the quad indexes referenced in mapQuads[y][x]
  #define ScreenQuadCount 256
  byte CharIndex[ScreenQuadCount][4]; //The graphic characters that make up the tile placement
  byte Chars[ScreenQuadCount][2]; //Which tiles for a zero or a 1 in the bits of a CharIndex
  byte ScatterIndex[ScreenQuadCount]; //Which fluff arrangement to add on top of above?
}ScreenQuad;
byte quadBuffer[4];

#define quadWidth 8
#define quadHeight 8
#define quadWidthDouble (quadWidth << 1)
#define quadHeightDouble (quadHeight << 1)
//#define yQuadHeight quadHeight << 1

static void FillQuadBuffer()
{
  byte row0, row1;
  byte quadX = characters.quadPosX[followIndex];
  byte quadY = characters.quadPosY[followIndex];
  byte byte_x = quadX + 1;
  byte byte_y = quadY + 1;
  //byte_x = (quadX + 1) % quadWidth;
  //byte_y = (quadY + 1) % quadHeight;
  if (byte_x == quadWidth) byte_x = 0;
  if (byte_y == quadHeight) byte_y = 0;

  row0 = mapMatrixWidth * quadY;
  row1 = mapMatrixWidth * byte_y; 

  quadBuffer[0] = mapQuads[quadX + row0]; 
  quadBuffer[1] = mapQuads[byte_x + row0]; 
  quadBuffer[2] = mapQuads[quadX + row1]; 
  quadBuffer[3] = mapQuads[byte_x + row1];
  //quadBuffer[0] = mapQuads[quadX + (mapMatrixWidth * quadY)];
  //quadBuffer[1] = mapQuads[byte_x + (mapMatrixWidth * quadY)];
  //quadBuffer[2] = mapQuads[quadX + (mapMatrixWidth * byte_y)];
  //quadBuffer[3] = mapQuads[byte_x + (mapMatrixWidth * byte_y)];
}

static const byte quadOriginsX[4] = 	{0, quadWidthDouble, 		0, 		quadWidthDouble}; 		//Tile Origin
static const byte quadOriginsY[4] = 	{0, 0, 				quadHeightDouble, 	quadHeightDouble};
static const byte quadOffsetX[4] = 	{0, quadWidth, 			0, 			quadWidth};		//Subchars
static const byte quadOffsetY[4] = 	{0, 0, 				quadHeight, 		quadHeight};
static void LoadQuadrant(byte quadIndex, byte quad)
{
  byte byte_y, byte_z;
  byte QuadOriginX, QuadOriginY;
  byte charByte;
  int rowStart;
  byte *out;
  const byte *tilePtr;
  byte mask;

  quadBuffer[quad] = quadIndex;

  for (byte_z = 0; byte_z < 4; ++byte_z)
  {
    QuadOriginX = quadOriginsX[quad] + quadOffsetX[byte_z];
    QuadOriginY = quadOriginsY[quad] + quadOffsetY[byte_z];
    // Precompute tile base pointer once per tile
    tilePtr = &MapSet[ScreenQuad.CharIndex[quadIndex][byte_z] << 3];
    for (byte_y = 0; byte_y < quadHeight; ++byte_y)
    {
      charByte = tilePtr[byte_y];
      rowStart = mapWidth * (byte_y + QuadOriginY);
      out = &mapData[QuadOriginX + rowStart];
      mask = 0x80;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0]; mask >>= 1;
      *out++ = ScreenQuad.Chars[quadIndex][(charByte & mask) != 0];
    }
  }
}

void LoadMapQuads()
{
  byte x;
  FillQuadBuffer();
  for (x = 0; x < 4; ++x)
    LoadQuadrant(quadBuffer[x], x);  
}

static byte GetPlayerQuad() //Returns the viewport quadrant of the player character
{
  if (characters.posX[followIndex] < quadWidthDouble)
  {
    if (characters.posY[followIndex] < quadHeightDouble)
      return 0;
    else
      return 2;
  }
  else
  {
    if (characters.posY[followIndex] < quadHeightDouble)
      return 1;
    else
      return 3;
  }
}

static byte GetQuadInRelation(sbyte v, sbyte h)
{
  //#pragma bss-name (push, "ZEROPAGE")
  sbyte int_x;
  sbyte int_y;
  //#pragma bss-name (pop)
  int_x = characters.quadPosX[followIndex];
  int_y = characters.quadPosY[followIndex];

  if (v < 0)
  {
    --int_y;
    if (int_y < 0)
      int_y = mapMatrixHeight - 1;
  }
  if (v > 0)
  {
    int_y++;
    if (int_y == mapMatrixHeight)
      int_y = 0;
  }
  if (h < 0)
  {
    int_x--;
    if (int_x < 0)
      int_x = mapMatrixWidth - 1;
  }
  if (h > 0)
  {
    ++int_x;
    if (int_x == mapMatrixWidth)
      int_x = 0;
  }
  return (mapQuads[int_x + (mapMatrixWidth * int_y)]);  
}

//Directional data for finding a relative quad
//left -UP DOWN LEFT RIGHT right UP DOWN LEFT RIGHT
static const sbyte quadRelationAV[8] = {-1,  1,  0,  0, -1, 1,  0, 0}; //vA
static const sbyte quadRelationBV[8] = {-1,  1, -1, -1, -1, 1,  1, 1}; //vB
static const sbyte quadRelationAH[8] = { 0,  0, -1,  1,  0, 0, -1, 1}; //hA
static const sbyte quadRelationBH[8] = {-1, -1, -1,  1,  1, 1, -1, 1}; //hB
//Quad positions in the matrix for which way we're moving
static const byte CompareQuadValueA[8] = {2, 3, 0, 1, 1, 0, 3, 2};
static const byte CompareQuadValueB[8] = {3, 2, 1, 0, 3, 2, 1, 0};

static void QuadScroll(direction dir)
{
  //#pragma bss-name (push, "ZEROPAGE")
  byte quadA; //Entering quad
  byte quadB; //Diagonal quad
  byte localX, localY;
  byte indexA;
  byte indexB;
  byte relH;
  byte relV;
  bool charPosX;
  bool charPosY;
  byte compareQuad;
  //#pragma bss-name (pop)

  relH = dir;
  relV = dir;
  localX = characters.posX[followIndex] & (TileSize - 1);
  localY = characters.posY[followIndex] & (TileSize - 1);
  charPosX = localX < quadWidth;
  charPosY = localY < quadHeight;
  //charPosX = (characters.posX[followIndex] % TileSize) < quadWidth;
  //charPosY = (characters.posY[followIndex] % TileSize) < quadHeight;
  compareQuad = GetPlayerQuad();

  if (!charPosX)
    relH += 4;
  if (!charPosY)
    relV += 4;

  indexA = GetQuadInRelation(quadRelationAV[relV], quadRelationAH[relH]);
  indexB = GetQuadInRelation(quadRelationBV[relV], quadRelationBH[relH]);

  if (dir > 1) //Is Horizontal?
    compareQuad += 4;

  quadA = CompareQuadValueA[compareQuad];
  quadB = CompareQuadValueB[compareQuad];

  if (quadBuffer[quadA] != indexA)
    LoadQuadrant(indexA, quadA);

  if (quadBuffer[quadB] != indexB)
    LoadQuadrant(indexB, quadB);
}

static void InitializeMapData()
{
  #define grass 36
  #define water 34
  #define signpost 35
  #define tree 44
  byte byte_x;
  byte byte_y;
  byte byte_i;
  byte byte_offset;
  byte byte_index = 0;
  //memset(&mapQuads[0], 0, 256);
  for (byte_y = 0; byte_y < 16; ++byte_y)
    for (byte_x = 0; byte_x < 16; ++byte_x)
    {
      mapQuads[byte_x + 16*byte_y] = byte_x + 16*byte_y;
    }

  for (byte_x = 0; byte_x < TileCount; ++byte_x)
  {
    tilesPalette[byte_x] = 1;
    tilesBlocked[byte_x] = 0;
    tilesOpaque[byte_x] = 0;

    if (byte_x < 8)
      tilesPalette[byte_x] = 0;
  }

  //Quad definitions (64 tiles)
  for (byte_y = 0; byte_y < 8; ++byte_y)
    for (byte_x = 0; byte_x < 8; ++byte_x)
    {
      byte_index = byte_x + (16* byte_y);
      byte_offset = (byte_x << 1) + (byte_y << 5);

      ScreenQuad.CharIndex[byte_index][0] = byte_offset; // Init screen quad prefabs for 8x8
      ScreenQuad.CharIndex[byte_index][1] = byte_offset + 1;
      ScreenQuad.CharIndex[byte_index][2] = byte_offset + 16;
      ScreenQuad.CharIndex[byte_index][3] = byte_offset + 17;
      //ScreenQuad.Chars[byte_index][0] = 32;
      //ScreenQuad.Chars[byte_index][1] = byte_index;
      ScreenQuad.Chars[byte_index][0] = grass;
      ScreenQuad.Chars[byte_index][1] = tree;
      ScreenQuad.ScatterIndex[byte_index] = 0;
      ;++byte_index;
    }
  tilesOpaque[44] = true; //Trees
  tilesPalette[44] = 3; //Trees
  tilesPalette[35] = 2; //Sign


  //ScreenQuad.Chars[2][0] = 36; // Set the wizard to grass on 0
  //ScreenQuad.Chars[2][1] = 44; // Set the wizard to trees on 1
  //Init Characters
  for (byte_i = 0; byte_i < charactersCount; ++byte_i)
  {
    characters.tile[byte_i] = byte_i;
    characters.posX[byte_i] = byte_i;
    characters.posY[byte_i] = byte_i;
    characters.quadPosX[byte_i] = byte_i;
    characters.quadPosY[byte_i] = byte_i;
    characters.visible[byte_i] = false;
    characters.collide[byte_i] = false;
  }
  characters.visible[0] = true;
  characters.posX[0]  = 12;
  characters.posY[0]  = 12;
  characters.quadPosX[0]  = 1;
  characters.quadPosY[0]  = 0;
  characters.tile[0] = 2;

  characters.visible[1] = true;
  characters.collide[1] = true;
  characters.message[1] = 0;

  characters.tile[2] = signpost;
  characters.visible[2] = true;
  characters.collide[2] = true;
  characters.message[2] = 1;
  characters.posX[2] = 12;
  characters.posY[2] = 11;
  characters.quadPosX[2]  = 1;
  characters.quadPosY[2]  = 0;

  LoadMapQuads();
  UpdatePlayerOnMiniMap();
  LOSEnabled = true;
}

static bool CheckCollision(byte charIndex, direction dir)
{
  byte byte_i;
  sbyte xPos = characters.posX[charIndex];
  sbyte yPos = characters.posY[charIndex]; //These need to be signed because they can wrap around the map

  //Check the tile we're already standing on
  if(ReadBit(tilesBlocked[mapData[xPos + (mapWidth * yPos)]], dir))
  {
    //WriteLineMessageWindow("Standing on blocked@", 0);
    return true;
  }

  switch (dir)
  {
    case up:
      --yPos;
      wrapY(yPos);
      break;
    case down:
      ++yPos;
      wrapY(yPos);
      break;
    case left:
      --xPos;
      wrapX(xPos);
      break;
    case right:
      ++xPos;
      wrapX(xPos);
      break;
    default:
      return false;
  }

  if(ReadBit(tilesBlocked[mapData[xPos + (mapWidth *yPos)]], dir))
  {
    /*WriteLineMessageWindow("Entry blocked@", 1);
    sprintf(str, "Index: %d@", tiles[mapData[xPos][yPos]].index);
    WriteLineMessageWindow(str, 1);
    sprintf(str, "Data: %d@", tiles[mapData[xPos][yPos]].blocked);
    WriteLineMessageWindow(str, 1);
    sprintf(str, "position: %d,%d@", xPos, yPos);
    WriteLineMessageWindow(str, 1);*/
    return true;
  }

  //Call Messagebox from NPC
  for (byte_i = 0; byte_i < charactersCount; ++byte_i)
    if(characters.collide[byte_i])
      if (characters.posX[byte_i] == xPos)
        if (characters.posY[byte_i] == yPos)
        {
          WriteLineMessageWindow((char*)Messages[characters.message[byte_i]], 1);
          return true;
        }

  return false;
}

static void DrawSquare(byte xOrigin, byte yOrigin, byte xSize, byte ySize) //LOS Blocking
{
  byte yEnd, row;
  int offset;
  if ( !xSize || !ySize )
    return;
  yEnd = yOrigin + ySize; 
  row = yOrigin;
  offset = (row * viewportWidth) + xOrigin;
  do { memset(&viewportBuffer[offset], EmptyTile, xSize); ++row; offset += viewportWidth; } while (row < yEnd);
}

static void ApplyLOS() //437bytes
{
  byte x = 0;
  byte y = 0;
  byte pX = playerX;
  byte pY = playerY;
  byte rowBase = 0;
  byte rowBaseX = 0;
  byte yDist = viewportHeight - y - 1;

  for (y = 0; y < viewportHeight; ++y)
  {
    byte yDist = viewportHeight - y - 1;
    for (x = 0; x < viewportWidth; ++x)
    {
      rowBaseX = x+ rowBase;
      if (viewportBuffer[rowBaseX] != EmptyTile)
        if (tilesOpaque[viewportBuffer[rowBaseX]])
        {
          byte xDist = viewportWidth - x - 1;
          
          if (x < pX)
          {
            if (y == pY)
            {
              DrawSquare(0, y-1, x, 3); //Left
              continue;
            }
            if (y < pY)
            {
              DrawSquare(0, 0, x, y); //Upper Left
              continue;
            }
            if (y > pY)
            {
              DrawSquare(0, y + 1, x, yDist); //Lower Left
              continue;
            }
          }
          if (x > pX)
          {
            if (y == pY)
            {
              DrawSquare(x + 1, y-1, xDist, 3); //Right
              continue;
            }
            if (y < pY)
            {
              DrawSquare(x + 1, 0, xDist, y); //Upper Right
              continue;
            }
            if (y > pY)
            {
              DrawSquare(x + 1, y + 1, xDist, yDist); //Lower Right
              continue;
            }
          }
          
          if (x == pX)
          {
            if (y < pY )
            {
              DrawSquare(x-1, 0, 3, y); //Up
              continue;
            }
            if (y > pY)
            {
              DrawSquare(x-1, y + 1, 3, yDist); //Down
              continue;
            }
          }
        }
    }
    rowBase += viewportWidth;
  }
}

static void DrawEntireMap()
{
  sbyte int_a;
  sbyte int_b;
  byte byte_x;
  byte byte_y;

  //Buffer the matrix of tiles for our viewport
  CameraFollow();
  int_a = offsetX;
  int_b = offsetY;
  for(byte_y = 0; byte_y < viewportHeight; ++byte_y)
  {
    wrapY(int_b); //Wrap the map data y reference
    for(byte_x = 0; byte_x < viewportWidth; ++byte_x)
    {
      wrapX(int_a); //Wrap the map data X reference
      viewportBuffer[byte_x + (viewportWidth * byte_y)] = mapData[int_a + (mapWidth * int_b)];      
      int_a++;
    }
    int_a = offsetX;
    ++int_b;
  }
  BufferCharacters();
  if(LOSEnabled)
    ApplyLOS();

  MapFadeOut();
  for(byte_y = 0; byte_y < viewportHeight; ++byte_y)
    for(byte_x = 0; byte_x < viewportWidth; ++byte_x)
    { //Only draw tiles that are different from the last draw; minimal effect on smaller screen sizes
      byte lastIndex = viewportBufferLast[byte_x + (viewportWidth * byte_y)];
      byte newIndex = viewportBuffer[byte_x + (viewportWidth * byte_y)];
      if (lastIndex != newIndex)
      {
        DrawTileX = byte_x;
        DrawTileY = byte_y;
        DrawTileIndex = newIndex;
        DrawTilePalette = tilesPalette[newIndex];
        DrawTileDirect();
      }
    }

  memcpy(&viewportBufferLast[0], &viewportBuffer[0], viewportSize);
  DrawCharacterCoordinates(followIndex);
  UpdateAttributes();
  MapFadeIn();
}

static void MoveCharacter(byte index, byte dir)
{
  bool scrollQuads = false;
  bool changedQuads = false;
  byte checkCollision = CheckCollision(index, dir);

  TickMoonPhase();
  if(!checkCollision)
  {
    switch (dir)
    {
      case up:
        --characters.posY[index];
        if (characters.posY[index] < 0)
          characters.posY[index] = mapHeight - 1;
        if (characters.posY[index] == 15 || characters.posY[index] == 31)
        {
          --characters.quadPosY[index];
          changedQuads = true;
          if(characters.quadPosY[index] < 0)
            characters.quadPosY[index] = mapMatrixHeight - 1;
        }
        break;
      case down:
        ++characters.posY[index];
        if (characters.posY[index] >= mapHeight)
          characters.posY[index] = 0;
        if (characters.posY[index] == 0 || characters.posY[index] == 16)
        {
          ++characters.quadPosY[index];
          changedQuads = true;
          if(characters.quadPosY[index] == mapMatrixHeight)
            characters.quadPosY[index] = 0; 
        }
        break;
      case left:
        --characters.posX[index];
        if (characters.posX[index] < 0)
          characters.posX[index] = mapWidth - 1;
        if (characters.posX[index] == 15 || characters.posX[index] == 31)
        {
          --characters.quadPosX[index];
          changedQuads = true;
          if(characters.quadPosX[index] < 0)
            characters.quadPosX[index] = mapMatrixWidth - 1; 
        }
        break;
      case right:
        ++characters.posX[index];
        if (characters.posX[index] >= mapWidth)
          characters.posX[index] = 0;
        if (characters.posX[index] == 0 || characters.posX[index] == 16)
        {
          ++characters.quadPosX[index];
          changedQuads = true;
          if(characters.quadPosX[index] == mapMatrixWidth)
            characters.quadPosX[index] = 0; 
        }
        break;
      default:
        break;
    }

    if (index == followIndex)
    {
      byte edgeCheckX = characters.posX[index] % 16;
      byte edgeCheckY = characters.posY[index] % 16;
      if(changedQuads)
        UpdatePlayerOnMiniMap();

      switch (dir)
      {
        case 0:
          if (edgeCheckY == 6)
            scrollQuads = true;
          break;
        case 1:
          if (edgeCheckY == 10)
            scrollQuads = true;
          break;
        case 2:
          if (edgeCheckX == 6)
            scrollQuads = true;
          break;
        case 3:
          if (edgeCheckX == 10)
            scrollQuads = true;
          break;
      }
      if (scrollQuads)
      {
        //SetBG(0x0b);
        //SetBorder(0x0b);
        QuadScroll(dir);
        //SetBG(0);
        //SetBorder(0);
      }
    }
    DrawEntireMap();
  }
}

static void DrawCharacterCoordinates(byte index)
{
  CoordPosX = characters.posX[index];
  CoordPosY = characters.posY[index];

  if (CoordPosX >= quadWidth * 2)
    CoordPosX -= quadWidth * 2;
  CoordPosX += quadWidth*2*characters.quadPosX[index];

  if (CoordPosY >= quadHeight * 2)
    CoordPosY -= quadHeight * 2;
  CoordPosY += quadHeight*2*characters.quadPosY[index];  

  sprintf(strTemp,"<%3i><%3i>@", CoordPosX, CoordPosY);
  PrintString(strTemp, viewportPosX + (viewportWidth >> 1), viewportPosY + (viewportHeight << 1), true);
}

void LoadMap()
{
  InitializeMapData();
}

//#define consoleDelay 1
//#define menuPosX  3 + ROWS - (ROWS - consoleWidth)
//#define menuPosY consolePosY - 1
#define menuWidth 13
#define menuCount 6
#define menuHeight menuCount

static void DrawMapViewport(void)
{
  memset(&viewportBufferLast, 255, viewportSize);
  DrawEntireMap();
  //DrawCharacterCoordinates(followIndex);
}
static void DrawScreen(void)
{
  DrawMapViewport();
  DrawCharStats();
}

static bool exitScreen;
static void ActionMenu()
{
  byte action;
  ResetMenu("@", contextMenuPosX, contextMenuPosY, contextMenuWidth, contextMenuHeight, menuCount);
  SetMenuItem(0, "Search@");
  SetMenuItem(1, "Attack@");
  SetMenuItem(2, "Party@");
  SetMenuItem(3, "Map@");
  SetMenuItem(4, "Exit@");
  SetMenuItem(5, "Charset@");

  action = GetMenuSelection();
  ClearMenu();
  switch (action)
  {
    case 0:
      break;
    case 1:
      break;
    case 2:
      break;
    case 3:
      UpdatePlayerOnMiniMap();
      ScreenFadeOut();
      ClearScreen();
      DrawMiniMap(true);
      WaitForInput();
      ScreenFadeOut();
      DrawMap();
      ScreenFadeIn();
      //DrawMapViewport();
      break;
    case 4:
      exitScreen = true;
      ScreenFadeOut();
      break;
    case 5:
      DrawCharset();
      WaitForInput();
      DrawMapViewport();
      break;
  }
  DrawCharStats();
}

void DrawMap()
{

  ResizeMessageWindow(consolePosX, consolePosY, consoleWidth, consoleHeight);
  DrawBorder("@", viewportPosX - 1, viewportPosY - 1, viewportWidth* 2 + 2, viewportHeight * 2 + 2, true);
  DrawScreen();
}

screenName MapUpdate()
{
  exitScreen = false;

  ResizeMessageWindow(consolePosX, consolePosY, consoleWidth, consoleHeight);
  DrawBorder("@", viewportPosX - 1, viewportPosY - 1, viewportWidth* 2 + 2, viewportHeight * 2 + 2, true);
  DrawCharStats();
  SetTileOrigin(viewportPosX, viewportPosY);
  LoadMapQuads();
  FillViewport(32, viewportWidth, viewportHeight);
  ScreenFadeIn();
  DrawMapViewport();

  while (!exitScreen)
  {
    UpdateInput();
    //if (InputChanged())
    {
      direction Dir = 4;
      if (InputUp())
        Dir = up;
      if (InputDown()) 
        Dir = down;
      if (InputLeft())
        Dir = left;
      if (InputRight())
        Dir = right;
      if (InputFire())
        if (InputChanged())
          ActionMenu();
      if (Dir < 4)
        MoveCharacter(followIndex, Dir);        
    }
  }
  ScreenFadeOut();
  return EditParty;
}
